<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wikidata Entity Viewer</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --background: #121212;
      --text: #E0E0E0;
      --neon: #00FF00;
      --neon-selected: #00FFFF;
      --header-bg: #222;
      --description-text: #A0A0A0;
      --watermark-color: #E0E0E0;
    }

    /* Ensure watermark is above the root background */
    .watermark {
      position: fixed;
      bottom: 20px;
      left: 30px;
      font-size: 6rem;
      color: var(--watermark-color);
      opacity: 0.1;
      pointer-events: none;
      text-transform: uppercase;
      font-weight: 700;
      z-index: 1; /* Changed from -1 to 1 to be above root background */
      max-width: 800px;
    }

    [data-theme="light"] {
      --background: #FFFFFF;
      --text: #333333;
      --neon: #FF00FF;
      --neon-selected: #FF007F;
      --header-bg: #F0F0F0;
      --description-text: #666666;
      --watermark-color: #333333;
    }

    html, body {
      background-color: var(--background);
      height: 100%;
    }

    body {
      color: var(--text);
      font-family: 'Orbitron', sans-serif;
      margin: 0;
      padding: 0;
      position: relative;
    }

    .app-wrapper {
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      position: relative;
      min-height: 100vh;
      z-index: 2;
    }



    main {
      padding: 20px;
      padding-bottom: 130px; /* Add extra bottom padding to avoid content being hidden behind language switcher */
    }

    h1, h2 {
      font-size: 2.5rem;
      text-shadow: 0 0 10px var(--neon);
      color: var(--neon);
      margin-bottom: 30px;
      line-height: 1;
    }

    h2 {
      font-size: 1.5rem;
      color: var(--text);
    }

    p {
      font-size: 1.2rem;
      line-height: 1.5;
      margin-bottom: 40px;
      color: var(--description-text);
    }

    .entity-info {
      position: relative;
      font-size: 1rem;
      color: var(--text);
      padding: 8px;
      margin: 20px 0;
      text-align: right;
      padding-top: 20px;
    }

    @media (max-width: 600px) {
      .entity-info {
        font-size: 0.9rem;
        padding: 6px;
        margin: 15px 0;
        padding-top: 15px;
      }
    }

    .entity-info a {
      color: var(--neon);
      text-decoration: none;
      pointer-events: auto;
      transition: color 0.3s ease;
    }

    .entity-info a:hover {
      color: var(--neon-selected);
      text-decoration: underline;
    }

    /* Statement link hover effects */
    .statement-link {
      color: var(--neon);
      text-decoration: none;
      transition: color 0.3s ease;
    }

    .statement-link:hover {
      color: var(--neon-selected);
      text-decoration: underline;
    }

    .language-switcher {
      position: fixed;
      bottom: 0;
      left: 20px;
      right: 20px;
      background-color: var(--header-bg);
      padding: 8px;
      text-align: center;
      overflow-x: auto;
      white-space: nowrap;
      z-index: 2;
    }

    .language-switcher button {
      background-color: transparent;
      border: 1px solid var(--header-bg);
      color: var(--text);
      font-size: 1.2rem;
      padding: 8px;
      margin: 0 8px;
      cursor: pointer;
    }

    .language-switcher button.selected {
      color: var(--neon-selected);
      border: 1px solid var(--neon-selected);
      border-radius: 4px;
    }

    .language-switcher button.preferred:not(.selected) {
      text-decoration: underline;
      text-decoration-color: var(--neon);
      text-decoration-thickness: 1px;
    }

    .language-switcher button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .theme-toggle {
      position: fixed;
      top: 20px;
      right: 20px;
      background-color: var(--header-bg);
      border: 2px solid var(--neon);
      color: var(--text);
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      cursor: pointer;
      border-radius: 4px;
      padding: 8px;
      margin: 0 8px;
    }

    @media (max-width: 600px) {
      h1 { font-size: 2rem; }
      h2 { margin-bottom: 25px; font-size: 1.2rem; }
      p { font-size: 1rem; margin-bottom: 30px; }
      .language-switcher { left: 10px; right: 10px; padding: 6px; }
      .language-switcher button { font-size: 1rem; padding: 6px; margin: 0 4px; }
      .theme-toggle { top: 10px; right: 10px; width: 30px; height: 30px; font-size: 1.2rem; padding: 6px; margin: 0 4px; }
      .watermark { font-size: 4rem; left: 10px; bottom: 10px; }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.development.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.24.0/babel.min.js"></script>
  <script src="settings.js"></script>
  <script type="text/babel">


    // IndexedDB setup
    const dbName = 'WikidataCache';
    const dbVersion = 1;
    const entityStore = 'entities';
    const propertyStore = 'properties';

    function openDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(dbName, dbVersion);
        
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);
        
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          
          // Create entity store
          if (!db.objectStoreNames.contains(entityStore)) {
            const entityObjectStore = db.createObjectStore(entityStore, { keyPath: 'id' });
            entityObjectStore.createIndex('timestamp', 'timestamp', { unique: false });
          }
          
          // Create property store
          if (!db.objectStoreNames.contains(propertyStore)) {
            const propertyObjectStore = db.createObjectStore(propertyStore, { keyPath: 'id' });
            propertyObjectStore.createIndex('timestamp', 'timestamp', { unique: false });
          }
        };
      });
    }

    async function getFromCache(storeName, id) {
      try {
        const db = await openDB();
        const transaction = db.transaction([storeName], 'readonly');
        const store = transaction.objectStore(storeName);
        const request = store.get(id);
        
        return new Promise((resolve, reject) => {
          request.onsuccess = () => {
            const data = request.result;
            if (data && data.timestamp) {
              // Check if cache is still valid (24 hours)
              const now = Date.now();
              const cacheAge = now - data.timestamp;
              const maxAge = 24 * 60 * 60 * 1000; // 24 hours
              
              if (cacheAge < maxAge) {
                resolve(data.data);
              } else {
                // Cache expired, remove it
                const deleteTransaction = db.transaction([storeName], 'readwrite');
                const deleteStore = deleteTransaction.objectStore(storeName);
                deleteStore.delete(id);
                resolve(null);
              }
            } else {
              resolve(null);
            }
          };
          request.onerror = () => reject(request.error);
        });
      } catch (error) {
        console.error('Error reading from cache:', error);
        return null;
      }
    }

    async function saveToCache(storeName, id, data) {
      try {
        const db = await openDB();
        const transaction = db.transaction([storeName], 'readwrite');
        const store = transaction.objectStore(storeName);
        
        const cacheEntry = {
          id,
          data,
          timestamp: Date.now()
        };
        
        store.put(cacheEntry);
      } catch (error) {
        console.error('Error saving to cache:', error);
      }
    }

    function EntityPage() {
      const [entityId, setEntityId] = React.useState(window.location.hash.slice(1) || 'Q35120');
      const [labels, setLabels] = React.useState({});
      const [descriptions, setDescriptions] = React.useState({});
      const [statements, setStatements] = React.useState([]);
      const [preferredLanguages, setPreferredLanguages] = React.useState([]);
      const [availableLanguages, setAvailableLanguages] = React.useState([]);
      const [selectedLanguage, setSelectedLanguage] = React.useState('');
      const [isLoading, setIsLoading] = React.useState(true);
      const [theme, setTheme] = React.useState(() => {
        const savedTheme = loadFromLocalStorage(STORAGE_KEYS.THEME, 'dark');
        return savedTheme;
      });
      const [propertyLabels, setPropertyLabels] = React.useState({});
      const [entityLabels, setEntityLabels] = React.useState({});

      React.useEffect(() => {
        document.documentElement.setAttribute('data-theme', theme);
      }, [theme]);

      React.useEffect(() => {
        // Load saved theme or use system preference
        const savedTheme = loadFromLocalStorage(STORAGE_KEYS.THEME, null);
        if (savedTheme) {
          setTheme(savedTheme);
        } else {
          const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
          setTheme(systemTheme);
        }
      }, []);

      React.useEffect(() => {
        const handleHashChange = () => {
          const newEntityId = window.location.hash.slice(1) || 'Q35120';
          console.log('Hash changed to:', newEntityId);
          setEntityId(newEntityId);
          setIsLoading(true);
          setPropertyLabels({});
          setEntityLabels({});
          setStatements({});
          setLabels({});
          setDescriptions({});
          setAvailableLanguages([]);
        };
        window.addEventListener('hashchange', handleHashChange);
        return () => window.removeEventListener('hashchange', handleHashChange);
      }, []);

      React.useEffect(() => {
        const loadEntityData = async () => {
          const preferredLangs = navigator.languages.map(lang => lang.split('-')[0]);
          const uniquePreferredLangs = [...new Set([...preferredLangs, 'en'])];
          setPreferredLanguages(uniquePreferredLangs);
          const commonLanguages = ['en', 'fr', 'de', 'es', 'it', 'pt', 'ru', 'zh', 'ja', 'ko', 'ar', 'hi', 'bn', 'ta', 'te', 'ml', 'ur', 'fa', 'tr', 'vi'];
          const allLanguages = [...new Set([...preferredLangs, ...commonLanguages])];
          const languages = allLanguages.join('|');

          setIsLoading(true);

          try {
            // Try to get entity data from cache first
            let entityData = await getFromCache(entityStore, entityId);
            console.log('Cached entity data for:', entityId, entityData);
            
            // Check if cached data is complete (has labels, descriptions, and claims)
            const isCachedDataComplete = entityData && 
              entityData.labels && 
              entityData.descriptions && 
              entityData.claims;
            
            if (!entityData || !isCachedDataComplete) {
              // Cache miss or incomplete data, fetch from API
              console.log('Fetching fresh data for entity:', entityId);
              const url = `https://www.wikidata.org/w/api.php?action=wbgetentities&ids=${entityId}&props=labels|descriptions|claims&languages=${languages}&format=json&origin=*`;
              const response = await fetch(url);
              
              if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
              }
              
              const data = await response.json();
              console.log('API response for entity:', entityId, data);
              entityData = data.entities[entityId];
              
              // Save to cache
              if (entityData) {
                await saveToCache(entityStore, entityId, entityData);
              }
            } else {
              console.log('Using cached data for entity:', entityId);
            }

            if (entityData) {
              console.log('Setting entity data for:', entityId, entityData);
              console.log('Claims count:', Object.keys(entityData.claims || {}).length);
              console.log('Entity data keys:', Object.keys(entityData));
              console.log('Claims object:', entityData.claims);
              setLabels(entityData.labels || {});
              setDescriptions(entityData.descriptions || {});
              setStatements(entityData.claims || {});
              const langSet = new Set([...Object.keys(entityData.labels || {}), ...Object.keys(entityData.descriptions || {})]);
              setAvailableLanguages(Array.from(langSet).sort());
              // Load saved language or use preferred language
              const savedLanguage = loadFromLocalStorage(STORAGE_KEYS.LANGUAGE, null);
              const initialLang = savedLanguage && langSet.has(savedLanguage) 
                ? savedLanguage 
                : uniquePreferredLangs.find(lang => langSet.has(lang)) || 'en';
              setSelectedLanguage(initialLang);
              
              // Extract property and entity IDs from statements
              const propertyIds = new Set();
              const entityIds = new Set();
              
              Object.values(entityData.claims || {}).forEach(claims => {
                if (Array.isArray(claims)) {
                  claims.forEach(claim => {
                    if (claim.mainsnak && claim.mainsnak.property) {
                      propertyIds.add(claim.mainsnak.property);
                    }
                    if (claim.mainsnak && claim.mainsnak.datavalue && claim.mainsnak.datavalue.value) {
                      const value = claim.mainsnak.datavalue.value;
                      if (claim.mainsnak.datatype === 'wikibase-item' && value.id) {
                        entityIds.add(value.id);
                      }
                    }
                  });
                }
              });
              
              // Load all labels in one go
              const allIds = [...propertyIds, ...entityIds];
              if (allIds.length > 0) {
                await loadAllLabels(allIds, languages);
              }
            } else {
              console.log('No entity data found for:', entityId);
              setLabels({});
              setDescriptions({});
              setStatements({});
              setAvailableLanguages([]);
              const savedLanguage = loadFromLocalStorage(STORAGE_KEYS.LANGUAGE, null);
              setSelectedLanguage(savedLanguage || uniquePreferredLangs[0] || 'en');
            }
            
            setIsLoading(false);
          } catch (error) {
            console.error('Error fetching data:', error);
            setLabels({});
            setDescriptions({});
            setStatements({});
            setAvailableLanguages([]);
            const savedLanguage = loadFromLocalStorage(STORAGE_KEYS.LANGUAGE, null);
            setSelectedLanguage(savedLanguage || uniquePreferredLangs[0] || 'en');
            setIsLoading(false);
          }
        };

        const loadAllLabels = async (ids, languages) => {
          console.log('Loading all labels for IDs:', ids);
          const newPropertyLabels = {};
          const newEntityLabels = {};
          const uncachedIds = [];

          // Check cache for each ID
          for (const id of ids) {
            const cachedData = await getFromCache(id.startsWith('P') ? propertyStore : entityStore, id);
            if (cachedData) {
              if (id.startsWith('P')) {
                newPropertyLabels[id] = cachedData.labels || {};
              } else {
                newEntityLabels[id] = cachedData.labels || {};
              }
            } else {
              uncachedIds.push(id);
            }
          }

          // Fetch uncached IDs from API in batches
          if (uncachedIds.length > 0) {
            const BATCH_SIZE = 50;
            for (let i = 0; i < uncachedIds.length; i += BATCH_SIZE) {
              const batchIds = uncachedIds.slice(i, i + BATCH_SIZE);
              const idsParam = batchIds.join('|');
              const labelsUrl = `https://www.wikidata.org/w/api.php?action=wbgetentities&ids=${idsParam}&props=labels&languages=${languages}&format=json&origin=*`;
              try {
                const response = await fetch(labelsUrl);
                if (response.ok) {
                  const data = await response.json();
                  if (!data.entities || Object.keys(data.entities).length === 0) {
                    console.error('No entities returned for label fetch:', batchIds);
                  }
                  Object.entries(data.entities || {}).forEach(([id, entity]) => {
                    // Save to cache
                    saveToCache(id.startsWith('P') ? propertyStore : entityStore, id, entity);
                    if (id.startsWith('P')) {
                      newPropertyLabels[id] = entity.labels || {};
                    } else if (id.startsWith('Q')) {
                      newEntityLabels[id] = entity.labels || {};
                    }
                  });
                } else {
                  console.error('Label fetch failed:', response.status, response.statusText);
                }
              } catch (error) {
                console.error('Error fetching labels:', error);
              }
            }
          }

          console.log('Setting property labels:', newPropertyLabels);
          console.log('Setting entity labels:', newEntityLabels);
          setPropertyLabels(newPropertyLabels);
          setEntityLabels(newEntityLabels);
        };

        loadEntityData();
      }, [entityId]);

      const toggleTheme = () => {
        setTheme(prevTheme => prevTheme === 'dark' ? 'light' : 'dark');
        saveToLocalStorage(STORAGE_KEYS.THEME, prevTheme === 'dark' ? 'light' : 'dark');
      };

      const getPropertyLabel = (propertyId) => {
        const labels = propertyLabels[propertyId];
        console.log('Getting property label for', propertyId, 'labels:', labels);
        if (labels && labels[selectedLanguage]) {
          return labels[selectedLanguage].value;
        }
        // Fallback to English
        if (labels && labels.en) {
          return labels.en.value;
        }
        // Fallback to any available language
        if (labels) {
          const firstLang = Object.keys(labels)[0];
          return labels[firstLang].value;
        }
        return propertyId;
      };

      const getEntityLabel = (entityId) => {
        const labels = entityLabels[entityId];
        console.log('Getting entity label for', entityId, 'labels:', labels);
        if (labels && labels[selectedLanguage]) {
          return labels[selectedLanguage].value;
        }
        // Fallback to English
        if (labels && labels.en) {
          return labels.en.value;
        }
        // Fallback to any available language
        if (labels) {
          const firstLang = Object.keys(labels)[0];
          return labels[firstLang].value;
        }
        return entityId;
      };

      const formatFactValue = (claim) => {
        if (claim.mainsnak.datavalue) {
          const value = claim.mainsnak.datavalue.value;
          if (claim.mainsnak.datatype === 'wikibase-item') {
            return getEntityLabel(value.id);
          } else if (claim.mainsnak.datatype === 'time') {
            return value.time;
          } else if (claim.mainsnak.datatype === 'quantity') {
            return value.amount;
          } else if (claim.mainsnak.datatype === 'string') {
            return value;
          } else if (claim.mainsnak.datatype === 'url') {
            return value;
          } else if (claim.mainsnak.datatype === 'monolingualtext') {
            return value.text;
          } else if (claim.mainsnak.datatype === 'globecoordinate') {
            return `${value.latitude}, ${value.longitude}`;
          }
          return JSON.stringify(value);
        }
        return 'No value';
      };

      const renderStatements = () => {
        const factElements = [];
        const currentEntityLabel = labels[selectedLanguage]?.value || entityId;
        
        console.log('Rendering statements with propertyLabels:', propertyLabels);
        console.log('Rendering statements with entityLabels:', entityLabels);
        
        for (const [propertyId, claims] of Object.entries(statements)) {
          if (Array.isArray(claims)) {
            claims.forEach((claim, index) => {
              const propertyLabel = getPropertyLabel(propertyId);
              const value = formatFactValue(claim);
              
              // Create clickable links for entities
              const entityLink = (
                <a 
                  href={`#${entityId}`} 
                  className="statement-link"
                  onClick={(e) => {
                    e.preventDefault();
                    window.location.hash = entityId;
                  }}
                >
                  {currentEntityLabel}
                </a>
              );
              
              const propertyLink = (
                <a 
                  href={`properties.html#${propertyId}`} 
                  className="statement-link"
                >
                  {propertyLabel}
                </a>
              );
              
              // Create value link if it's an entity
              let valueElement = value;
              if (claim.mainsnak.datatype === 'wikibase-item' && claim.mainsnak.datavalue?.value?.id) {
                const valueEntityId = claim.mainsnak.datavalue.value.id;
                valueElement = (
                  <a 
                    href={`#${valueEntityId}`} 
                    className="statement-link"
                    onClick={(e) => {
                      e.preventDefault();
                      window.location.hash = valueEntityId;
                    }}
                  >
                    {value}
                  </a>
                );
              }
              
              factElements.push(
                <div key={`${propertyId}-${index}`} style={{ 
                  marginBottom: '10px', 
                  padding: '10px', 
                  border: '1px solid var(--neon)', 
                  borderRadius: '4px',
                  backgroundColor: 'rgba(0, 255, 0, 0.05)'
                }}>
                  {entityLink} {propertyLink} {valueElement}
                </div>
              );
            });
          }
        }
        return factElements;
      };

      console.log('Loading state:', { isLoading, propertyLabelsCount: Object.keys(propertyLabels).length, entityLabelsCount: Object.keys(entityLabels).length, statementsCount: Object.keys(statements).length });
      if (isLoading) {
        return <div style={{ textAlign: 'center', marginTop: '50px' }}>Loading...</div>;
      }

      const currentLabel = labels[selectedLanguage]?.value || 'No label available';
      const otherLabels = preferredLanguages.filter(lang => lang !== selectedLanguage && labels[lang]);
      const sortedLanguages = [selectedLanguage, ...otherLabels];
      const descriptionsList = sortedLanguages.map(lang => descriptions[lang]?.value).filter(desc => desc);

      return (
        <div className="app-wrapper">
          <button className="theme-toggle" onClick={toggleTheme}>
            {theme === 'dark' ? '‚òÄÔ∏è' : 'üåô'}
          </button>
          <main>
            <h1>{currentLabel}</h1>
            {otherLabels.map(lang => (
              <h2 key={lang}>{labels[lang]?.value || 'No label available'}</h2>
            ))}
            {descriptionsList.length > 0 ? (
              descriptionsList.map((desc, index) => (
                <p key={index}>{desc}</p>
              ))
            ) : (
              <p>No description available</p>
            )}
            
            <h2>Statements</h2>
            {Object.keys(statements).length > 0 ? (
              <div style={{ marginTop: '20px' }}>
                {renderStatements()}
              </div>
            ) : (
              <p>No statements available</p>
            )}
            
            <div className="entity-info">
              <span>Data source: </span>
              <a href={`https://www.wikidata.org/wiki/${entityId}`} target="_blank" rel="noopener noreferrer">{entityId}</a>
            </div>
          </main>
          <div className="language-switcher">
            {availableLanguages.map(lang => (
              <button
                key={lang}
                className={`${lang === selectedLanguage ? 'selected' : ''} ${
                  preferredLanguages.includes(lang) && lang !== selectedLanguage ? 'preferred' : ''
                }`}
                onClick={() => {
                  setSelectedLanguage(lang);
                  saveToLocalStorage(STORAGE_KEYS.LANGUAGE, lang);
                }}
              >
                {flagMap[lang] || lang}
              </button>
            ))}
          </div>
          <div className="watermark">entity</div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<EntityPage />);
  </script>
</body>
</html>